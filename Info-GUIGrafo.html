<!DOCTYPE html>
<html class="centro">
    <head>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <link rel="stylesheet" href="style.css">
    </head>
    <p style="display: none; background:linear-gradient(skyBlue,rgb(0, 80, 255)) padding-box text;-webkit-text-fill-color: transparent;" id="futureTitle">GUI Grafo</p>
    <body class="contenuto">
    
        <font family="Verdana" size="6">
            <p id="titolo">
                Come è nata l'idea
            </p>
        </font>
        <font family="Verdana">
            <p>
                Iniziando un corso di informatica, a scuola, in testa girava l'idea di creare un programma capace di creare dei grafi e 
                mi piaceva il fatto di visualizzare su gui il cammino più breve tra due nodi usando l' <span id="codice">Algoritmo di Dijkstra</span>.
                
            </p>
        </font>
        
        <br>
        
        <font family="Verdana" size="6">
            <p id="titolo">
                Fase di Sviluppo
            </p>
        </font>
        
        <font family="Verdana">
            <p>
                Sono partito dell'idea di creare un programma molto simile al <a href="Info-SoftwareCAD.html" class="passami-sopra">Software CAD</a> con l'unica cosa che bisognava aggiungere qualche figura in più
                quando si creano linee, meglio dire <span id="codice">Archi</span>. <br>
                Ogni Arco che si crea vengono creati due nodi, se premo su un nodo l'arco parte da quel nodo e finisce su un altro. Ogni arco ha il suo peso e di default viene calcolata la distanza cartesiana dal centro dei due nodi e viene divisa per 15, successivamente viene inserita in una casella di testo.<br>
                Premendo il <span id="codice">tasto destro</span> sull'Arco, viene aperto un piccolo menù in cui viene specificato:
                <ul>
                    <li> 
                        <span id="codice">Direzione</span> che indica il nodo di partenza e di destinazione
                    </li>
                    
                    <li> 
                        <span id="codice">Peso</span> dell'arco, che se premuto sopra si può cambiare
                    </li>
                    
                    <li>
                        <span id="codice">Bidirezionale</span> appare un tick (✔) se l'arco è bidirezionale, altrimenti non comparirà nulla, se premuto l'arco viene considerato bidirezionale
                    </li>
                </ul>
                Si possono poi fare diverse cose, come trovare la <span id="codice">distanza minima</span> tra due nodi usando l'<span id="codice">Algoritmo di Dijkstra</span> e
                in caso di errore <span id="codice">cancellare</span> l'<span id="codice">Arco</span>, il programma poi capirà quali nodi dovrà cancellare.
            </p>
        </font>
        
        
        <font family="Verdana" size="6">
            <p id="titolo">
                Commento sul Codice
            </p>
        </font>
        
        <font>
            <h2>- Classe Nodo</h2>
            <code>
                <ol>
                    <li>
                        class Nodo:
                    </li>
                    <li>
                        <span id="spazio"></span> def __init__(self, coords: list[tuple], n:int, line_id: int):
                    </li>
                    
                    <li>
                        <span id="spazio" style="--spaziatura: 2"></span>self.__coords = coords
                    </li>
                    
                    <li>
                        <span id="spazio" style="--spaziatura: 2"></span>self.__number = n
                    </li>
                    
                    <li>
                        <span id="spazio" style="--spaziatura: 2"></span>self.__line_id = line_id
                    </li>
                    
                    <li>
                        <br>
                    </li>
                    
                    <li>
                        <span id="spazio"></span>def getCoords(self):
                    </li>
                    
                    <li>
                        <span id="spazio" style="--spaziatura: 2"></span>return self.__coords
                    </li>
                    
                    <li>
                        <br>
                    </li>
                    
                    <li>
                        <span id="spazio"></span>def getNumber(self):
                    </li>
                    
                    <li>
                        <span id="spazio" style="--spaziatura: 2"></span>return self.__number
                    </li> 
                    
                    <li>
                        <br>
                    </li>
                    <li>
                        <span id="spazio"></span>def getId(self):
                    </li>
                    
                    <li>
                        <span id="spazio" style="--spaziatura: 2"></span>return self.__line_id
                    </li>
                </ol>
            </code>
            
            Questo è come vede il programma i <span id="codice">Nodi</span> dei grafi. Composto da: 
            <ul>
                <li>
                    <span id="codice">Coordinate</span> del centro del nodo
                </li>
                
                <li>
                    <span id="codice">Numero</span> del nodo
                </li>
                
                <li>
                    <span id="codice">ID </span> della linea del canvas
                </li>
            </ul>
            Gli attributi per convenzione li ho dichiarati privati, in python non avendo una <span id="codice">keyword</span> che specifica
            esplicitamente l'<span id="codice">ambito di visibilità</span> si usano i <span id="codice">doppi underscore</span> per indicare
            un attributo/metodo privato. <br>
            Per il resto non c'è nulla di particolare e il codice riesce a parlare da solo.
        </font>
        
        <br>
        <br>
        
        <font>
            <h2>- Classe Arco</h2>
            <code>
                <ol>
                    <li>class Arco:</li> 
                    <li><span id="spazio"></span> def __init__(self, coords: list[tuple], nodes: list[Nodo], height:int, line_id:int, bidirectional = False,**kargs):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__coords = coords</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__nodes = nodes</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__height = height</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__line_id = line_id</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__bidirectional = bidirectional</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__kargs = kargs</li>
                    <li></li>
                    <li><span id="spazio"></span>def getCoords(self):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return self.__coords</li>
                    <li></li>
                    <li><span id="spazio"></span>def getNodes(self):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return self.__nodes</li>
                    <li></li>
                    <li><span id="spazio"></span>def getHeight(self):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return self.__height</li>
                    <li></li>
                    <li><span id="spazio"></span>def getId(self):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return self.__line_id</li>
                    <li></li>
                    <li><span id="spazio"></span>def getBidirectional(self) -> bool:</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return self.__bidirectional</li>
                    <li></li>
                    <li><span id="spazio"></span>def getKargs(self):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return self.__kargs</li>
                    <li></li>
                    <li><span id="spazio"></span>def getScheme(self, withHeight = True):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>s = ""</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>s += " ".join([str(n.getNumber()) for n in self.__nodes])</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>if withHeight:</li>
                    <li><span id="spazio" style="--spaziatura: 3"></span>s += f" {self.__height}"</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>if self.__bidirectional:</li>
                    <li><span id="spazio" style="--spaziatura: 3"></span>s1 = s.split(" ")</li>
                    <li><span id="spazio" style="--spaziatura: 3"></span>s1[0], s1[1] = s1[1], s1[0]</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 3"></span>s1 = " ".join(s1)</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 3"></span>s += f"\n{s1}"</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return s.strip()</li>
                    <li></li>
                    <li><span id="spazio"></span>def getTotalInfo(self):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>s = self.__coords.copy()</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>s.append({})</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>if self.__bidirectional:</li>
                    <li><span id="spazio" style="--spaziatura: 3"></span>s[-1]["BIDIREZIONALE"] = 1</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>s[-1]["PESO"] = self.__height</li>
                    <li></li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>return s</li>
                    <li></li>
                    <li></li>
                    <li><span id="spazio"></span># ------------------------------------------ #</li>
                    <li></li>
                    <li><span id="spazio"></span>def toggleBidirectional(self):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__bidirectional = not self.__bidirectional</li>
                    <li></li>
                    <li><span id="spazio"></span>def setBidirectional(self, value):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__bidirectional = value</li>
                    <li></li>
                    <li><span id="spazio"></span>def setHeight(self, value):</li>
                    <li><span id="spazio" style="--spaziatura: 2"></span>self.__height = value</li>
                </ol>
            </code>
            
            Questo è come vede il programma gli <span id="codice">Archi</span>. Composto da: 
            <ul>
                <li>
                    <span id="codice">coords</span> in cui specifica le coordinate dell'arco
                </li>
                <li>
                    <span id="codice">nodes</span> è l'array formato da due nodi, quello di partenza e di destinazione
                </li>
                <li>
                    <span id="codice">height</span> indica il peso dell'arco
                </li>
                <li>
                    <span id="codice">line_id</span> è l'identificativo dell'arco nel canvas
                </li>
                <li>
                    <span id="codice">bidirectional</span> di default impostato su False, indica se l'arco è bidirezionale o meno
                </li>
                <li>
                    <span id="codice">**kargs</span>, sono degli argomenti aggiuntivi, marcati da una <span id="codice">chiave</span> (key)
                </li>
            </ul>
            Sui metodi <span id="codice">get</span> non c'è molto da dire in quanto hanno un semplice return. C'è da aggiungere qualcosa
            su <span id="codice">getScheme</span> & <span id="codice">getTotalInfo</span>:
            <ul>
                <li>
                    Il metodo <span id="codice">getScheme</span> ritorna sotto forma di stringa il nodo di partenza, di fine e il peso. <br>
                    Il parametro <span id="codice">withHeight</span>, impostato di default su <span id="codice">True</span>, mi aggiunge o meno
                    il peso alla fine.
                    <br>
                    <br>
                    Su riga <span id="codice">31</span>, <span id="codice">s += " ".join([str(n.getNumber()) for n in self.__nodes])</span>, prendo l'array dei
                    <span id="codice">Nodi</span> e vado a richiamare il metodo <span id="codice">getNumber</span> in modo da ottenere il numero del nodo, e se bidirezionale
                    mi va a copiare lo schema precedente e va aggiungere gli stessi nodi, ma invertiti. <br>
                    Infine il <span id="codice">return s.strip()</span>, ritorna lo schema strippato, in modo da non esserci spazi in eccesso.
                </li>
                <br>
                <li>
                    Il metodo <span id="codice">getTotalInfo</span>, invece di ritornarmi lo schema di nodi, mi ritorna un array composo dalle 
                    <span id="codice">coordinate cartesiane</span> dell'arco, seguito da un dizionario in cui si distinguono, il <span id="codice">peso</span>
                    e il fatto di essere <span id="codice">bidirezionale</span>, che se impostato è 1, altrimenti non c'è.
                </li>
            </ul>
            
            Successivamente abbiamo i metodi <span id="codice">set</span> e uno particolare, <span id="codice">toggle</span>. 
            I metodi <span id="codice">set</span> impostano il valore il valore del <span id="codice">peso</span>(<span id="codice">setHeight</span>) e il
            valore del <span id="codice">bidirezionale</span> (<span id="codice">setBidirectional</span>), solo che ancora non l'ho usato. <br>
            Il metodo che uso è il metodo <span id="codice">toggleBidirectional</span> in cui semplicemente mi inverte il valore del <span id="codice">self.__bidirectional</span>
            
        </font>
        
        <br>
        <br>
        
        <font family="Verdana">
            <h2>- Recezione Errore</h2>
            <code>
                <ol>
                    <li>def logFunzione(func):</li>
                    <li><span id='spazio'></span>def wrapper(*args):</li>
                    <li><span id='spazio' style='--spaziatura: 2'></span>try:</li>
                    <li><span id='spazio' style='--spaziatura: 3'></span>func(*args)</li>
                    <li><span id='spazio' style='--spaziatura: 2'></span>except:</li>
                    <li><span id='spazio' style='--spaziatura: 3'></span>err = traceback.format_exc()</li>
                    <li><span id='spazio' style='--spaziatura: 3'></span>ora = time.strftime("%d-%m-%Y | %H:%M", time.localtime())</li>
                    <li><span id='spazio' style='--spaziatura: 3'></span></li>
                    <li><span id='spazio' style='--spaziatura: 3'></span>messagebox.showerror("Notifica di Servizio", "Si è verificato un errore. Chiedere più informazioni al proprietario del software")</li>
                    <li><span id='spazio' style='--spaziatura: 3'></span></li>
                    <li><span id='spazio' style='--spaziatura: 3'></span>with open("log.txt", "a") as file:</li>
                    <li><span id='spazio' style='--spaziatura: 4'></span>file.write(f"[{ora}] =>{err}\n{'-'*130}\n")</li>
                    <li><span id='spazio' style='--spaziatura: 3'></span>file.close()</li>
                    <li><span id='spazio'></span></li>
                    <li><span id='spazio'></span>return wrapper</li>
                    <li></li>
                    <li># ------------------------------------------ #</li>
                    <li></li>
                    <li>class GUI(ctk.CTk):</li>
                    <li><span id='spazio'></span>....</li>
                    <li><span id='spazio'></span>@logFunzione</li>
                    <li><span id='spazio'></span>def setPoint(self, event): </li>
                    <li><span id='spazio' style='--spaziatura: 2'></span>...</li>
                </ol>
            </code>
            
            Per controllare gli eventuali errori che si verificano durante l'eseguzione del programma, senza riscrivere molto codice
            ho introdotto un <a href="https://www.programmareinpython.it/video-corso-python-intermedio/12-i-decoratori/" target="_blank" id="codice">decoratore</a>. <br>
            Usando il blocco <span id="codice">try-except</span> riesco a trovare gli errori che che avvengono nella funzione, in questo caso una essenziale perché riguarda
            il posizionamento di <span id="codice">Nodi</span> & <span id="codice">Archi</span>, per trovare poi l'errore utilizzo il <span id="codice">traceback</span> che mi fornisce
            dettagli sull'errore e viene salvato nel file <span id="codice">log.txt</span>. <br>
            Quando si verifica un errore appare un messaggio, che dice di segnalarmelo, ho programmato una funzione segreta che mi permette di accedere al file dei <span id="codice">log</span>.
            Per accedere bisogna fare <span id="codice">tasto destro</span> sul bottone <span id="codice">Cancella Tutto</span> e si aprirà una finestra in cui ci sarà il contenuto del file di <span id="codice">log</span>.
        </font>
        
        <br>
        <br>
        
        <font family="Verdana">
            <h2>- Creazione Arco</h2>
            
            <code>
                <ol>
                    <li>self.archi += 1</li>
                    <li>temp = self.temp_coods.copy()</li>
                    <li>pm = [(temp[0][0] + temp[1][0])/2, (temp[0][1] + temp[1][1])/2] </li>
                    <li></li>
                    <li>try: angle = math.degrees(math.atan2((temp[0][1] - temp[1][1]), (temp[0][0] - temp[1][0])))</li>
                    <li>except: angle = 90</li>
                    <li></li>
                    <li>lenght = math.sqrt((temp[0][0] - temp[1][0])**2 + (temp[0][1] - temp[1][1])**2)</li>
                    <li>lenght /= 2</li>
                    <li>lenght -= 10 </li>
                    <li></li>
                    <li>temp = list(map(lambda x: list(x), temp))</li>
                    <li>temp[0][0] = lenght*cos(angle) + pm[0]         # x</li>
                    <li>temp[0][1] = lenght*sin(angle) + pm[1]         # y</li>
                    <li></li>
                    <li>temp[1][0] = lenght*cos(angle+180) + pm[0]     # x </li>
                    <li>temp[1][1] = lenght*sin(angle+180) + pm[1]     # y</li>
                    <li></li>
                    <li>line = self.canvas.create_line(temp, fill="white", arrow="last", arrowshape=(7.0, 11.0, 6.0), activewidth=3, width=2)</li>
                </ol>
                </code>
            
            Per iniziare incremento il contatore degli archi <span id="codice">self.archi += 1</span>. <br>
            Successivamente mi copio le coordinate in una variabile <span id="codice">temp</span>. <br>
            L'obiettivo è accorciare la linea di 10 punti, perché se lasciata di default oltre dare fastidio all'occhio, il grafo non è graficamente corretto. <br>
            Ora, usando un po di goniometria, considero la linea come il diametro di un cerchio che ha come raggio, la lunghezza della linea. <br>
            Calcolandomi il punto medio (<span id="codice">pm</span>), che lo considero come centro della mia circonferenza, mi trovo la pendenza della linea (<span id="codice">angle</span>) e 
            la sua lunghezza (<span id="codice">lenght</span>). <br>
            Visto che la lunghezza la considero come il diametro, la divido per 2, in modo da ottenere il <span id="codice">raggio</span> della mia circonferenza, e da li gli tolgo 10 punti, dato che serve più corta. <br>
            Adesso per sapere le nuove coordinate dei punti utilizzo la <a href="https://edulab.unitn.it/wp-content/uploads/nfs/DiCoMat/curve/book_curve.pdf#subsection.1.3.1" target="_blank" id="codice">parametrizzazione di una circonferenza</a>, usando
            come raggio, la nuova lunghezza <span id="codice">lenght</span> e come angolo <span id="codice">angle</span>. Faccio una precisazione sulle ultime righe dove esce, come argomento del seno e coseno, <span id="codice">angle+180</span> che è semplicemente una regola
            degli <a href="https://www.andreaminini.org/matematica/trigonometria/angoli-associati-alfa-e-pi-greco-piu-alfa" target="_blank" id="codice">angoli associati</a> e, <span id="codice">pm[0]</span> e <span id="codice">pm[1]</span> sono le coordinate <span id="codice">x</span> e <span id="codice">y</span>
            del centro della circonferenza. <br>
            Infine creo la linea (<span id="codice">line</span>) con la lista di coordinate <span id="codice">temp</span>.
            
            <br>
            <br>
            
            <h2>- Riconoscimento Click</h3>
                <code>
                    <ol>
                        <li>if self.permitted_coods[0][0]:</li>
                        <li><span id='spazio'></span>self.nodi += 1</li>
                        <li><span id='spazio'></span>nodo1 = self.canvas.create_oval((x1,y1),(x2,y2), fill="#202123", outline="white", activewidth=2)</li>
                        <li><span id='spazio'></span>text_nodo1 = self.canvas.create_text(self.temp_coods[0], text=str(self.nodi), activefill="red", fill="white", state="disabled")</li>
                        <li><span id='spazio'></span></li>
                        <li><span id='spazio'></span>ogg_nodo1 = Nodo(self.temp_coods[0], self.nodi, nodo1)</li>
                        <li><span id='spazio'></span>self.canvas.itemconfig(nodo1, tags=([pickle.dumps(ogg_nodo1)]))</li>
                        <li><span id='spazio'></span></li>
                        <li><span id='spazio'></span>if event.num == 2:</li>
                        <li><span id='spazio' style='--spaziatura: 2'></span>x,y = self.temp_coods[0]</li>
                        <li><span id='spazio' style='--spaziatura: 2'></span>self.dict_nodes[f"{x} {y}"] = [(x,y), pickle.dumps(ogg_nodo1)]</li>
                        <li><span id='spazio'></span></li>
                        <li>else:</li>
                        <li><span id='spazio'></span>ogg_nodo1 = pickle.loads(self.permitted_coods[0][1])</li>
                    </ol>
                </code>
            
            <span id="codice">self.permitted_coods</span> è una matrice 2x2 in cui dice lo stato attuale nell'esatto punto in cui ho premuto, il primo elemento è un <span id="codice">booleano</span> 
            in cui mi dice se è uno spazio vuoto o meno, ciò lo determina usando i <span id="codice">tags</span>, se c'è una determianta condizione usando quel tag, sa se è uno spazio vuoto o meno.
            Il secondo elemento è il tag stesso. <br>
            Se lo spazio è vuoto (<span id="codice">if self.permitted_coods[0][0]</span>) incrementa di 1 il counter dei nodi, <span id="codice">self.nodi += 1</span> e crea la parte visiva del nodo (<span id="codice">nodo1</span>) rappresentandolo come un cerchio e il testo del numero del nodo.
            Poi viene creato un <span id="codice">oggetto</span> di tipo <span id="codice">Nodo</span>, il costruttore accetta:
                <ul>
                    <li>
                        <span id="codice">Coordinate</span> del centro del nodo
                    </li>
                    <li>
                        <span id="codice">Numero</span> del nodo (che il quel momento viene rappresentato da <span id="codice">self.nodi</span>)
                    </li>
                    <li>
                        <span id="codice">ID</span> del disegno del cerchio (<span id="codice">nodo1</span>), nel suo <span id="codice">tag</span> sarà racchiuso l'<span id="codice">oggetto</span> interpretato da <span id="codice">pickle</span>
                    </li>
                </ul>
            
            Dove si vede <span id="codice">if event.num == 2</span> è un "metodo" per quando si deve caricare un file sul programma, quindi, senza creare un altra funzione che faccia la stessa identica cosa, all'evento gli modifico il parametro <span id="codice">num</span> 
            e lo imposto uguale a 2. <br>
            In un evento <span id="codice">num</span> è il numero del pulsante del mouse    
                <ul>
                    <li><span id="codice">1</span> tasto sinistro del mouse</li>
                    <li><span id="codice">2</span> tasto centrale del mouse</li>
                    <li><span id="codice">3</span> tasto destro del mouse</li>
                </ul>
            quindi quando si chiama la funzione per quando si preme il tasto sinistro del mouse, il parametro <span id="codice">num</span> è sempre 1, impostandolo quindi a 2 capisce che si tratta di un caricamento del file e non di un suo utilizzo normale,
            prende le coordinate dall'array <span id="codice">self.temp_coods</span> e lo inserire in un dizionario (conosciuto come <span id="codice">dict</span>) che ha come <span id="codice">key</span> le coordinate sottoforma di stringa e come 
            <span id="codice">value</span> le coordinate insieme all'<span id="codice">oggetto Nodo</span> interpretato da <span id="codice">pickle</span>.
            Quando invece rileva qualcosa recupera l'oggetto contenuto in <span id="codice">self.permitted_coods[0][1]</span> utilizzando <span id="codice">pickle</span>. <br>
            
            
        </font>
        
        <br>
        <script src="script.js"></script>
        <button id="tornaindietro" class="bottonetornaindietro" onclick="location.pathname = '/'">Torna Indietro</button>
    
    </body>
    
</html>
